# Technical Specification: LiquidityWorker

## Overview
The **LiquidityWorker** is the execution unit responsible for acting on signals generated by the **SentimentWorker**. It translates sentiment signals into specific liquidity actions (e.g., adding/removing liquidity from pools) while adhering to predefined safety guardrails.

---

## Input Interface
The LiquidityWorker receives data from the SentimentWorker via a JSON payload named `SentimentSignal`. The expected structure of `SentimentSignal` is as follows:

```json
{
  "action": "BUY" | "SELL",  // The recommended action (BUY or SELL)
  "confidence": 0.0-1.0,     // Confidence level of the signal (0.0 to 1.0)
  "asset": "VIRTUAL",        // The asset identifier (e.g., token symbol)
  "timestamp": "ISO8601"     // Timestamp of the signal generation
}
```

**Integration Details**:
- Input: Received via a RESTful API endpoint (`POST /liquidity-signal`) or pub/sub messaging system (e.g., Kafka or RabbitMQ).
- Validation: The LiquidityWorker validates the `SentimentSignal` payload for completeness and correctness before processing.

---

## Decision Logic (The "Brain")
The LiquidityWorker translates a `SentimentSignal` into a specific liquidity action based on the following logic:

### 1. Action Mapping
- **BUY Signal**: Add liquidity to the pool for the specified asset.
- **SELL Signal**: Remove liquidity from the pool for the specified asset.

### 2. Confidence Scaling
- Higher confidence levels result in larger trade sizes, scaled proportionally.
- Formula for trade size:  
  `tradeSize = baseAmount + (maxAmount - baseAmount) * confidence`

| Parameter       | Value       | Description                                     |
|------------------|-------------|-------------------------------------------------|
| `baseAmount`     | 100         | Minimum amount to trade (units of asset).      |
| `maxAmount`      | 1000        | Maximum amount to trade (units of asset).      |

### 3. Example
- **Input**: `"action": "BUY", "confidence": 0.8, "asset": "VIRTUAL"`
- **Calculation**: `tradeSize = 100 + (1000 - 100) * 0.8 = 820`
- **Output Action**: Add 820 units of `VIRTUAL` to the liquidity pool.

---

## Safety Guardrails (Critical)
To prevent catastrophic failures and ensure responsible trading, the LiquidityWorker implements the following safety mechanisms:

### 1. Max Daily Spend
- Cap on the total amount deployed per 24-hour period.
- **Parameter**: `maxDailySpend = 5000` (units of asset).
- Mechanism: Cumulative tracking of all trades within the last 24 hours. Reject any trade that would exceed this limit.

### 2. Stop Loss
- Automatically reverts actions if the portfolio value drops below a threshold.
- **Parameter**: `stopLossThreshold = 0.9` (90% of initial portfolio value).
- Mechanism: Monitor portfolio value after each trade. If the value drops below `stopLossThreshold`, trigger a sell-off or revert to a safe state.

### 3. Minimum Liquidity
- Prevent actions that would leave the pool with insufficient liquidity.
- **Parameter**: `minLiquidity = 200` (units of asset).
- Mechanism: Check and enforce this limit before executing any trade.

---

## Output/Action
The LiquidityWorker interacts with the `ProtocolBridge` to execute transactions on the blockchain. It uses the following methods:

### 1. `addLiquidity(asset, amount)`
- Adds `amount` of `asset` to the liquidity pool.
- Example Call:  
  `ProtocolBridge.addLiquidity("VIRTUAL", 820)`

### 2. `removeLiquidity(asset, amount)`
- Removes `amount` of `asset` from the liquidity pool.
- Example Call:  
  `ProtocolBridge.removeLiquidity("VIRTUAL", 820)`

### 3. `getPortfolioValue()`
- Retrieves the current value of the portfolio in USD.
- Used for stop-loss calculations.

### 4. `getLiquidity(asset)`
- Retrieves the current liquidity balance of `asset` in the pool.
- Used for enforcing `minLiquidity`.

---

## Error Handling
The LiquidityWorker handles the following errors:
- **Invalid Signal**: Discards malformed or incomplete `SentimentSignal` payloads.
- **Trade Failure**: Logs and retries failed transactions (up to 3 retries).
- **Safety Breach**: Halts trading and raises an alert if any safety parameter is violated.

---

## Integration Points
1. **SentimentWorker**: Receives `SentimentSignal` via API or messaging system.
2. **ProtocolBridge**: Executes liquidity actions and retrieves portfolio/liquidity data.
3. **Monitoring System**: Logs all actions and alerts on critical events.

---

## Sequence Diagram (Example Flow)
```plaintext
SentimentWorker → LiquidityWorker: SentimentSignal
LiquidityWorker → ProtocolBridge: getPortfolioValue()
LiquidityWorker → ProtocolBridge: getLiquidity("VIRTUAL")
LiquidityWorker: Calculates trade size and validates safety parameters
LiquidityWorker → ProtocolBridge: addLiquidity("VIRTUAL", 820)
ProtocolBridge → LiquidityWorker: Transaction Receipt
LiquidityWorker → Monitoring System: Logs action
```

---

## Next Steps
1. Implement the `LiquidityWorker` class with the described logic.
2. Integrate with the `SentimentWorker` and `ProtocolBridge`.
3. Test and deploy the system with mock data before live trading.